# LangChain과 LangGraph

## LangGraph란

- 대규모 언어 모델을 활용한 복잡한 워크 플로우와 의사결정 프로세스를 구현
- 멀티 에이전트 기반의 LLM 애플리케이션을 효과적으로 만들 수 있는 강력한 기술
- 랭체인 팀에서 지원하는 프레임워크

- Rangchain : 개발 과정이 상대적으로 간단하지만 복잡한 워크 플로우 관리에는 한계가 존재
- RangGraph : 랭체인 기반이지만, 상태 기반 그래프 구조를 통해 복잡하고 동적인 워크 플로우 구성

| 특징 | LangGraph | LangChain |
| --- | --- | --- |
| 주요 목적 | **복잡한** 워크 플로우 및 의사결정 프로세스 구현 | LLM 통합 및 체인 구성 |
| 구조 | **그래프** 기반 | 체인 및 에이전트 기반 |
| 상태 관리 | 명시적이고 세밀한 제어 | 암시적이고 자동화된 관리 |
| 유연성 | 높음 (커스텀 로직 쉽게 구현) | 중간 (미리 정의된 컴포넌트 중심) |
| 학습 곡선 | 상대적으로 가파름 (랭체인 → 랭그래프 학습) | 상대적으로 완만 |
| 용도 | 복잡한 AI 시스템 (RAG 등), 멀티 에이전트 | 간단한 LLM 애플리케이션 RAG |

# 사용 기술

## StateGraph

- 상태(State)를 기반으로 작동하는 그래프 구조
- 복잡한 작업 흐름을 상태와 전이로 모델링해 유연하고 제어가능한 시스템 구축
- 각 노드(node)가 특정 상태를 나타내며, edge가 상태 간 전이 조건을 정의함

## 조건부 엣지

## State Reducer

- 상태 업데이트를 관리하는 함수
- 그래프의 각 노드의 출력을 그래프의 전체 상태에 통합하는 방법을 정의

## Message Graph

- LangChain의 ChatModel을 위한 특수한 형태의 StateGraph
- Message 객체 목록 (HumanMessage, AIMessage 등)을 입력으로 처리
- 대화 기록을 효과적으로 관리하고 활용 가능 (자연스러운 대화 흐름, 컨텍스트 활용 답변)

## ReAct (Reasoning + Act)

- 추론(Resoning)과 행동(Acting)을 결합한 접근 방식
- LLM이 단순히 텍스트를 생성하는 것을 넘어, 환경과 상호작용하며 복잡한 작업 수행

## Tool node

- AI 모델이 필요한 도구(Tool) 호출을 실행하는 역할을 처리하는 LangGraph 컴포넌트

## Memory Saver

- 그래프 각 단계 실행 후 자동으로 상태를 저장 (체크포인터 역할)
- 상태의 일시성(stateless) 문제 해결 (즉, 그래프는 각 실행마다 새로운 상태로 초기화되는 문제)
- 대화의 연속성(멀티 턴), 대화 중단 후 복원 가능
- 독립적인 대화 스레드 관리

## Adaptive RAG

- 질문 복잡성에 따라 가장 적합한 검색 및 생성 전략을 동적으로 선택하는 방법

## Self-RAG

- 기존 RAG 모델에 자기 반영(self-reflection)능력을 추가한 확장 모델
- 정보 검색, 생성, 그리고 자체 평가를 통합해 더 정확하고 관련성 높은 응답을 생성하는 것을 목표

## Sub Graph

- 각 서브 그래프가 독립적인 상태를 관리
- 메인 그래프와 서브 그래프 간의 정보 교환 지원
- 모듈화된 설계로 복잡한 워크플로우 구현 용이

## Corrective RAG

- 기존 RAG 시스템을 개선해 검색된 정보의 품질과 관련성을 향상시키는 접근 방식
- 문서 관련성 평가, 지식 정제, 필요 시 외부 지식 탐색, 정제된 지식을 바탕으로 한 답변 생성
